# -*- coding: utf-8 -*-
"""Delaporte_Solene_analyze_traffic_dataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p5V0Mz1hdyp7QXnilJrF9jJGpgWBM99J
"""

!pip install --upgrade pandas-profiling

!pip install mlforecast

"""# Analyze traffic dataset ✈

Use fbprophet, nixtla ml forecast and nixtla neural forecaster.
"""

import pandas as pd

from pandas_profiling import ProfileReport
#from ydata_profiling import ProfileReport # from April, 1st 2023

traffic_df = pd.read_parquet('traffic_10lines.parquet')

traffic_df.describe(include='all').transpose()

profile_report = ProfileReport(traffic_df)

profile_report.to_notebook_iframe()

traffic_df

(traffic_df
 .groupby(['home_airport', 'paired_airport', 'direction'])
 .agg(date_min=('date', 'min'), date_max=('date', 'max'), pax=('pax', 'sum'))
 .reset_index()
)

"""## Visualization"""

(traffic_df
 .query('home_airport == "NTE" and paired_airport == "FUE"')
 ['airline_name']
 .value_counts()
)

(traffic_df
 .query('home_airport == "NTE" and paired_airport == "FUE"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
 .set_index('date')
 ['pax_total']
 .plot(figsize=(12, 6))
);



# Commented out IPython magic to ensure Python compatibility.
# Si vous êtes sous Jupyter
# %matplotlib inline

(traffic_df
 .query('home_airport == "LGW" and paired_airport == "AMS"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
 .set_index('date')
 ['pax_total']
 .plot(figsize=(12, 6))
);

import seaborn as sns

sns.set()

(traffic_df
 .query('home_airport == "LGW" and paired_airport == "AMS"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
 .set_index('date')
 ['pax_total']
 .plot(figsize=(12, 6))
);

import datetime
import plotly

import plotly.offline as pyoff
import plotly.graph_objs as go

from plotly.subplots import make_subplots


def draw_ts_multiple(df: pd.DataFrame, v1: str, v2: str=None, prediction: str=None, date: str='date',
              secondary_y=True, covid_zone=False, display=True):
  """Draw times series possibly on two y axis, with COVID period option.

  Args:
  - df (pd.DataFrame): time series dataframe (one line per date, series in columns)
  - v1 (str | list[str]): name or list of names of the series to plot on the first x axis
  - v2 (str): name of the serie to plot on the second y axis (default: None)
  - prediction (str): name of v1 hat (prediction) displayed with a dotted line (default: None)
  - date (str): name of date column for time (default: 'date')
  - secondary_y (bool): use a secondary y axis if v2 is used (default: True)
  - covid_zone (bool): highlight COVID-19 period with a grayed rectangle (default: False)
  - display (bool): display figure otherwise just return the figure (default: True)

  Returns:
  - fig (plotly.graph_objs._figure.Figure): Plotly figure generated

  Notes:
  Make sure to use the semi-colon trick if you don't want to have the figure displayed twice.
  Or use `display=False`.
  """
  if isinstance(v1, str):
    variables = [(v1, 'V1')]
  else:
    variables = [(v, 'V1.{}'.format(i)) for i, v in enumerate(v1)]
  title = '<br>'.join([n + ': '+ v for v, n in variables]) + ('<br>V2: ' + v2) if v2 else '<br>'.join([v + ': '+ n for v, n in variables])
  layout = dict(
    title=title,
    xaxis=dict(
        rangeselector=dict(
            buttons=list([
                dict(count=1,
                     label='1m',
                     step='month',
                     stepmode='backward'),
                dict(count=6,
                     label='6m',
                     step='month',
                     stepmode='backward'),
                dict(step='all')
            ])
        ),
        rangeslider=dict(
            visible = True
        ),
        type='date'
    )
  )
  fig = make_subplots(specs=[[{"secondary_y": True}]])
  fig.update_layout(layout)
  for v, name in variables:
    fig.add_trace(go.Scatter(x=df[date], y=df[v], name=name), secondary_y=False)
  if v2:
    fig.add_trace(go.Scatter(x=df[date], y=df[v2], name='V2'), secondary_y=secondary_y)
    fig['layout']['yaxis2']['showgrid'] = False
    fig.update_yaxes(rangemode='tozero')
    fig.update_layout(margin=dict(t=125 + 30 * (len(variables) - 1)))
  if prediction:
    fig.add_trace(go.Scatter(x=df[date], y=df[prediction], name='^V1', line={'dash': 'dot'}), secondary_y=False)

  if covid_zone:
    fig.add_vrect(
        x0=pd.Timestamp("2020-03-01"), x1=pd.Timestamp("2022-01-01"),
        fillcolor="Gray", opacity=0.5,
        layer="below", line_width=0,
    )
  if display:
    pyoff.iplot(fig)
  return fig

draw_ts_multiple(
    (traffic_df
     .query('home_airport == "LGW" and paired_airport == "AMS"')
     .groupby(['home_airport', 'paired_airport', 'date'])
     .agg(pax_total=('pax', 'sum'))
     .reset_index()
    ),
    'pax_total',
    covid_zone=True,
)

"""ajout affciher les données d'une route

"""

import plotly.graph_objects as go

# Filter the data for the specific route
filtered_data = traffic_df.query('home_airport == "NTE" and paired_airport == "FUE"')

# Group the data by date and calculate the total passenger count
grouped_data = filtered_data.groupby(['home_airport', 'paired_airport', 'date']).agg(
    pax_total=('pax', 'sum')
).reset_index()

# Create the Plotly graph
fig = go.Figure(data=go.Scatter(x=grouped_data['date'], y=grouped_data['pax_total'], mode='lines'))
fig.update_layout(title='Passenger Traffic on Route', xaxis_title='Date', yaxis_title='Passenger Count')

# Display the graph
fig.show()

import plotly.graph_objects as go
import plotly.subplots as sp
import pandas as pd
import plotly.offline as pyoff

def draw_ts_multiple(df: pd.DataFrame, v1: str, v2: str=None, prediction: str=None, date: str='date',
              secondary_y=True, covid_zone=False):
    fig = sp.make_subplots(specs=[[{"secondary_y": secondary_y}]])
    fig.update_layout(
        title=f"Time Series Analysis",
        xaxis=dict(
            rangeselector=dict(
                buttons=list([
                    dict(count=1,
                         label='1m',
                         step='month',
                         stepmode='backward'),
                    dict(count=6,
                         label='6m',
                         step='month',
                         stepmode='backward'),
                    dict(step='all')
                ])
            ),
            rangeslider=dict(visible=True),
            type='date'
        )
    )
    fig.update_yaxes(title_text="Primary Y-axis", secondary_y=False)
    if v2:
        fig.update_yaxes(title_text="Secondary Y-axis", secondary_y=True)
    
    fig.add_trace(go.Scatter(x=df[date], y=df[v1], name="V1"), secondary_y=False)
    
    if v2:
        fig.add_trace(go.Scatter(x=df[date], y=df[v2], name="V2"), secondary_y=True)
    
    if prediction:
        fig.add_trace(go.Scatter(x=df[date], y=df[prediction], name="Prediction", line=dict(dash='dot')), secondary_y=False)
    
    if covid_zone:
        fig.add_vrect(
            x0=pd.Timestamp("2020-03-01"), x1=pd.Timestamp("2022-01-01"),
            fillcolor="Gray", opacity=0.5,
            layer="below", line_width=0
        )
    
    pyoff.plot(fig)

draw_ts_multiple(df, 'v1', 'v2', 'prediction', 'date', True, True)

import pandas as pd
import numpy as np

# Création d'un DataFrame fictif
dates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='D')
v1_data = np.random.rand(len(dates))
v2_data = np.random.rand(len(dates))
prediction_data = np.random.rand(len(dates))

df = pd.DataFrame({'date': dates, 'v1': v1_data, 'v2': v2_data, 'prediction': prediction_data})

draw_ts_multiple(df, 'v1', 'v2', 'prediction', 'date', True, True)

import datetime
import plotly

import plotly.offline as pyoff
import plotly.graph_objs as go

from plotly.subplots import make_subplots


def draw_ts_multiple(df, v1, v2=None, prediction=None, date='date',
                     secondary_y=True, covid_zone=False, display=True):
    """Draw times series possibly on two y axis, with COVID period option.
  
    Args:
    - df (pd.DataFrame): time series dataframe (one line per date, series in columns)
    - v1 (str | list[str]): name or list of names of the series to plot on the first x axis
    - v2 (str): name of the serie to plot on the second y axis (default: None)
    - prediction (str): name of v1 hat (prediction) displayed with a dotted line (default: None)
    - date (str): name of date column for time (default: 'date')
    - secondary_y (bool): use a secondary y axis if v2 is used (default: True)
    - covid_zone (bool): highlight COVID-19 period with a grayed rectangle (default: False)
    - display (bool): display figure otherwise just return the figure (default: True)
  
    Returns:
    - fig (plotly.graph_objs._figure.Figure): Plotly figure generated
  
    Notes:
    Make sure to use the semi-colon trick if you don't want to have the figure displayed twice.
    Or use `display=False`.
    """
    if isinstance(v1, str):
        variables = [(v1, 'V1')]
    else:
        variables = [(v, 'V1.{}'.format(i)) for i, v in enumerate(v1)]
    title = '<br>'.join([n + ': '+ v for v, n in variables]) + ('<br>V2: ' + v2) if v2 else '<br>'.join([v + ': '+ n for v, n in variables])
    layout = dict(
        title=title,
        xaxis=dict(
            rangeselector=dict(
                buttons=list([
                    dict(count=1,
                         label='1m',
                         step='month',
                         stepmode='backward'),
                    dict(count=6,
                         label='6m',
                         step='month',
                         stepmode='backward'),
                    dict(step='all')
                ])
            ),
            rangeslider=dict(
                visible=True
            ),
            type='date'
        )
    )
    fig = make_subplots(specs=[[{"secondary_y": True}]])
    fig.update_layout(layout)
    for v, name in variables:
        fig.add_trace(go.Scatter(x=df[date], y=df[v], name=name), secondary_y=False)
    if v2:
        fig.add_trace(go.Scatter(x=df[date], y=df[v2], name='V2'), secondary_y=secondary_y)
        fig['layout']['yaxis2']['showgrid'] = False
        fig.update_yaxes(rangemode='tozero')
        fig.update_layout(margin=dict(t=125 + 30 * (len(variables) - 1)))
    if prediction:
        fig.add_trace(go.Scatter(x=df[date], y=df[prediction], name='^V1', line={'dash': 'dot'}), secondary_y=False)

    if covid_zone:
        fig.add_vrect(
            x0=datetime.datetime(2020, 3, 1), x1=datetime.datetime(2022, 1, 1),
            fillcolor="Gray", opacity=0.5,
            layer="below", line_width=0,
        )
    if display:
        pyoff.iplot(fig)
    return fig

# Utilisation du code pour afficher les données de la route LGW-AMS
draw_ts_multiple(
    (traffic_df
     .query('home_airport == "LGW" and paired_airport == "AMS"')
     .groupby(['home_airport', 'paired_airport', 'date'])
     .agg(pax_total=('pax', 'sum'))
     .reset_index()
    ),
    'pax_total',
    covid_zone=True,
)

import plotly.graph_objs as go
import plotly.offline as pyoff

def plot_route_data(df, home_airport, paired_airport):
    route_df = df[(df['home_airport'] == home_airport) & (df['paired_airport'] == paired_airport)]
    fig = go.Figure(data=go.Scatter(x=route_df['date'], y=route_df['pax'], mode='lines'))
    fig.update_layout(title=f"Route {home_airport} - {paired_airport}",
                      xaxis_title='Date',
                      yaxis_title='Passenger Count')
    pyoff.iplot(fig)

# Utilisation du code pour afficher les données de la route NTE-FUE
plot_route_data(traffic_df, 'NTE', 'FUE')

import plotly.graph_objects as go

# Création de la trace de vol
flight_trace = go.Scattergeo(
    mode = "lines",
    lon = df['homeAirport'],      # Colonne contenant les longitudes de départ des vols
    lat = df['pairedAirport'],    # Colonne contenant les latitudes de départ des vols
    hoverinfo = 'text',
    text = df['flight_number'],   # Colonne contenant les numéros de vol
    line = dict(width = 1, color = 'blue'),
)

# Création de la carte
layout = go.Layout(
    title_text = "Itinéraire des vols",
    showlegend = False,
    geo = dict(
        resolution = 110,
        showland = True,
        showlakes = True,
        landcolor = 'rgb(243, 243, 243)',
        countrycolor = 'rgb(204, 204, 204)',
        lakecolor = 'rgb(255, 255, 255)',
        projection_type = "equirectangular",
        coastlinewidth = 2,
        lataxis = dict(
            range = [df['pairedAirport'].min()-2, df['pairedAirport'].max()+2],
            showgrid = True,
            dtick = 10
        ),
        lonaxis = dict(
            range = [df['homeAirport'].min()-2, df['homeAirport'].max()+2],
            showgrid = True,
            dtick = 20
        )
    )
)

# Création de la figure
fig = go.Figure(data=flight_trace, layout=layout)
fig.show()



nte_fue_df = (traffic_df
 .query('home_airport == "NTE" and paired_airport == "FUE"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
)
nte_fue_df

lgw_ams_df = (traffic_df
 .query('home_airport == "LGW" and paired_airport == "AMS"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
)
lgw_ams_df

"""## First model with Facebook"""

def generate_route_df(traffic_df: pd.DataFrame, homeAirport: str, pairedAirport: str) -> pd.DataFrame:
  """Extract route dataframe from traffic dataframe for route from home airport to paired airport

  Args:
  - traffic_df (pd.DataFrame): traffic dataframe
  - homeAirport (str): IATA Code for home airport
  - pairedAirport (str): IATA Code for paired airport

  Returns:
  - pd.DataFrame: aggregated daily PAX traffic on route (home-paired)
  """
  _df = (traffic_df
         .query('home_airport == "{home}" and paired_airport == "{paired}"'.format(home=homeAirport, paired=pairedAirport))
         .groupby(['home_airport', 'paired_airport', 'date'])
         .agg(pax_total=('pax', 'sum'))
         .reset_index()
         )
  return _df

generate_route_df(traffic_df, "LGW", "AMS")

from prophet import Prophet

baseline_model = Prophet()
baseline_model.fit(generate_route_df(traffic_df, "NTE", "FUE").rename(columns={'date': 'ds', 'pax_total': 'y'}))

future_df = baseline_model.make_future_dataframe(periods=15) # Prepare to predict 15 days
future_df

forecast_df = baseline_model.predict(future_df)

forecast_df

graph = baseline_model.plot(forecast_df)

baseline_model.plot_components(forecast_df);

"""### Evaluate performance"""

from prophet.diagnostics import cross_validation

eval_df = cross_validation(baseline_model, initial='366 days', period='90 days', horizon='90 days')

eval_df

from prophet.diagnostics import performance_metrics

performance_metrics(eval_df)

from prophet.plot import plot_cross_validation_metric

plot_cross_validation_metric(eval_df, metric='rmse');

"""### Automate model fitting and evaluation"""

routes = (traffic_df
 .drop_duplicates(subset=['home_airport', 'paired_airport'])
 [['home_airport', 'paired_airport']]
 .to_dict(orient='rows')
)

import logging
logging.getLogger('cmdstanpy').setLevel(logging.WARNING)
#logging.getLogger('prophet').setLevel(logging.WARNING)

models = dict()
performances = dict()

for route in routes:
  print(route)
  home = route['home_airport']
  paired = route['paired_airport']
  # Build route traffic dataframe
  _df = generate_route_df(traffic_df, home, paired)
  # Create a model
  _model = Prophet()
  # Fit the model
  _model.fit(_df.rename(columns={'date': 'ds', 'pax_total': 'y'}))
  # Cross validate the model
  _cv_df = cross_validation(_model, horizon='90 days', parallel="processes")
  _perf_df = performance_metrics(_cv_df, rolling_window=1)
  # Save results
  models[(route['home_airport'], route['paired_airport'])] = _model
  performances[(route['home_airport'], route['paired_airport'])] = _perf_df['rmse'].values[0]

models

performances

"""### Save models"""

from prophet.serialize import model_to_json, model_from_json

for model in models:
  _filename = 'route_model_prophet_{home}_{paired}.json'.format(home=model[0], paired=model[1])
  with open(_filename, 'w') as f:
    f.write(model_to_json(models[model]))

reload_models = dict()

for route in routes:
  _filename = 'route_model_prophet_{home}_{paired}.json'.format(home=route['home_airport'],
                                                                paired=route['paired_airport'])
  with open(_filename, 'r') as f:
    reload_models[(route['home_airport'], route['paired_airport'])] = model_from_json(f.read())

reload_models

from joblib import dump, load

for model in models:
  _filename = 'route_model_prophet_{home}_{paired}.joblib'.format(home=model[0], paired=model[1])
  dump(models[model], _filename)

reload_models = dict()

for route in routes:
  _filename = 'route_model_prophet_{home}_{paired}.joblib'.format(home=route['home_airport'],
                                                                  paired=route['paired_airport'])
  reload_models[(route['home_airport'], route['paired_airport'])] = load(_filename)

reload_models

"""## Model with Nixtla

# Nouvelle section
"""

import lightgbm as lgb
import xgboost as xgb
from sklearn.ensemble import RandomForestRegressor

from mlforecast import MLForecast
from numba import njit
from window_ops.expanding import expanding_mean
from window_ops.rolling import rolling_mean

tested_models = [
    lgb.LGBMRegressor(),
    xgb.XGBRegressor(),
    RandomForestRegressor(random_state=0),
]

@njit
def rolling_mean_28(x):
    return rolling_mean(x, window_size=28)


fcst = MLForecast(
    models=tested_models,
    freq='D',
    lags=[7, 14, 21, 28],
    lag_transforms={
        1: [expanding_mean],
        7: [rolling_mean_28]
    },
    date_features=['dayofweek'],
    differences=[1],
)

nixtla_model = fcst.fit(generate_route_df(traffic_df, "LGW", "AMS").drop(columns=['paired_airport']),
                        id_col='home_airport', time_col='date', target_col='pax_total')

predict_df = nixtla_model.predict(14)
predict_df

(pd.concat([generate_route_df(traffic_df, 'LGW', 'AMS').drop(columns=['paired_airport']),
            nixtla_model.predict(7*10)])
.set_index('date')
).plot(figsize=(15, 7));

draw_ts_multiple((pd.concat([generate_route_df(traffic_df, 'LGW', 'AMS').drop(columns=['paired_airport']),
                             nixtla_model.predict(7*10)])),
                 v1='pax_total', v2='LGBMRegressor');

crossvalidation_df = fcst.cross_validation(
    data=generate_route_df(traffic_df, "LGW", "AMS").drop(columns=['paired_airport']),
    window_size=90,
    n_windows=5,
    id_col='home_airport',
    time_col='date',
    target_col='pax_total'
)

crossvalidation_df

import numpy as np

def mse(y, y_hat):
  delta_y = np.square(y - y_hat)
  return np.nanmean(delta_y)

def rmse(y, y_hat):
  delta_y = np.square(y - y_hat)
  return np.sqrt(mse(y, y_hat))

cv_rmse = crossvalidation_df.groupby(['home_airport', 'cutoff']).apply(lambda df: rmse(df['pax_total'], df['LGBMRegressor'])).mean()
print("LGBM RMSE using cross-validation: ", cv_rmse)
cv_rmse = crossvalidation_df.groupby(['home_airport', 'cutoff']).apply(lambda df: rmse(df['pax_total'], df['RandomForestRegressor'])).mean()
print("RandomForest RMSE using cross-validation: ", cv_rmse)
cv_rmse = crossvalidation_df.groupby(['home_airport', 'cutoff']).apply(lambda df: rmse(df['pax_total'], df['XGBRegressor'])).mean()
print("XGBoost RMSE using cross-validation: ", cv_rmse)

cv_rmse = (crossvalidation_df
           .assign(Ensemble=lambda _df: _df[['LGBMRegressor', 'RandomForestRegressor', 'XGBRegressor']].mean(axis=1))
           .groupby(['home_airport', 'cutoff']).apply(lambda df: rmse(df['pax_total'], df['Ensemble'])).mean())
print("Ensemble RMSE using cross-validation: ", cv_rmse)

"""## Model avec Neural Forecast"""

!pip install neuralforecast

from neuralforecast import NeuralForecast
from neuralforecast.models import NBEATS, NHITS

horizon = 90
models = [NBEATS(input_size=2 * horizon, h=horizon, max_epochs=50),
          NHITS(input_size=2 * horizon, h=horizon, max_epochs=50)]

nforecast = NeuralForecast(models=models, freq='D')
nforecast.fit(df=generate_route_df(traffic_df, "LGW", "AMS").drop(columns=['paired_airport']).rename(columns={'home_airport': 'unique_id',
                                                                                                      'date': 'ds',
                                                                                                      'pax_total': 'y'}))

nforecast.predict().reset_index()

pd.concat(
    [
        generate_route_df(traffic_df, "LGW", "AMS").drop(columns=['paired_airport']).rename(columns={'home_airport': 'unique_id',
                                                                                                     'date': 'ds',
                                                                                                     'pax_total': 'y'}),
        nforecast.predict().reset_index()
    ]
).set_index('ds').plot(figsize=(15,7))

"""solène"""

!pip install setuptools

!pip install pystan==2.19.1.1
!pip install numpy==1.20.0
!pip install pandas==1.2.0
!pip install convertdate==2.3.0
!pip install holidays==0.11.0
!pip install matplotlib==3.3.3
!pip install seaborn==0.11.1

!pip install fbprophet

!pip install fbprophet

from fbprophet import Prophet

# Filtrer les données pour la route spécifique
route_data = traffic_df.query('home_airport == "LGW" and paired_airport == "AMS"')

# Agréger les données par date
aggregated_data = route_data.groupby('date').sum()['pax_total'].reset_index()

# Renommer les colonnes pour Prophet
aggregated_data = aggregated_data.rename(columns={'date': 'ds', 'pax_total': 'y'})

# Entraîner le modèle Prophet
model = Prophet()
model.fit(aggregated_data)

# Générer des dates pour la prévision
future_dates = model.make_future_dataframe(periods=7)  # Prévision pour 7 jours supplémentaires

# Effectuer la prévision
forecast = model.predict(future_dates)

# Afficher la prévision
model.plot(forecast, xlabel='Date', ylabel='Pax Total')
model.plot_components(forecast)

"""Question2"""

!pip install fbprophet

!pip install --upgrade setuptools wheel

!pip install --no-build-isolation fbprophet

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/facebook/prophet.git
# %cd prophet
!pip install --no-build-isolation .

from fbprophet import Prophet
import pandas as pd

# Charger les données spécifiques de la route
data = pd.read_csv('chemin_vers_vos_donnees.csv')

# Filtrer les données pour la route spécifique que vous souhaitez prévoir
route_data = data[(data['home_airport'] == 'NTE') & (data['paired_airport'] == 'FUE')]

# Préparation des données avec les colonnes "ds" (date) et "y" (variable cible)
prepared_data = route_data[['date', 'pax']].rename(columns={'date': 'ds', 'pax': 'y'})

# Créer une instance du modèle Prophet
model = Prophet()

# Entraîner le modèle sur les données
model.fit(prepared_data)

# Prévoir pour x jours
future_dates = model.make_future_dataframe(periods=7)  # Prévoir pour 7 jours à partir de la dernière date des données
forecast = model.predict(future_dates)

# Afficher les prévisions
print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7))





"""# questions

##1.Affichage des données d’une route (homeAirport – pairedAirport) sous forme d’un
graphique Plotly
"""

import pandas as pd

# Filtrer les données pour le trajet ORY - LIS
filtered_data = traffic_df.query('home_airport == "LIS" and paired_airport == "ORY"')

# Compter le nombre de vols par compagnie aérienne
airline_counts = filtered_data['airline_name'].value_counts()

print(airline_counts)

(traffic_df
 .query('home_airport == "LIS" and paired_airport == "ORY"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
 .set_index('date')
 ['pax_total']
 .plot(figsize=(12, 6))
);

import plotly.graph_objects as go

# Obtention des données de vol agrégées pour la route spécifiée
route_data = (traffic_df
              .groupby(['home_airport', 'paired_airport', 'direction'])
              .agg(date_min=('date', 'min'), date_max=('date', 'max'), pax=('pax', 'sum'))
              .reset_index())

# Filtrer les données pour la route LIS - ORY
filtered_data = route_data.query('home_airport == "LIS" and paired_airport == "ORY"')

# Création de la trace de vol
flight_trace = go.Scatter(
    x = filtered_data['direction'],
    y = filtered_data['pax'],
    mode = 'lines+markers',
    line = dict(color='blue'),
    marker = dict(symbol='circle', size=6, color='blue'),
    hovertemplate = 'Direction: %{x}<br>Pax: %{y}',
    name = 'Pax'
)

# Création de la mise en page du graphique
layout = go.Layout(
    title = 'Données de la route LIS - ORY',
    xaxis = dict(title='Direction'),
    yaxis = dict(title='Pax'),
    showlegend = False
)

# Création de la figure
fig = go.Figure(data=flight_trace, layout=layout)
fig.show()

import plotly.graph_objects as go

# Obtention des données de vol agrégées pour la route spécifiée
route_data = (traffic_df
              .groupby(['home_airport', 'paired_airport', 'direction'])
              .agg(date_min=('date', 'min'), date_max=('date', 'max'), pax=('pax', 'sum'))
              .reset_index())

# Création de la trace de vol
flight_trace = go.Scatter(
    x = route_data['direction'],
    y = route_data['pax'],
    mode = 'lines+markers',
    line = dict(color='blue'),
    marker = dict(symbol='circle', size=6, color='blue'),
    hovertemplate = 'Direction: %{x}<br>Pax: %{y}',
    name = 'Pax'
)

# Création de la mise en page du graphique
layout = go.Layout(
    title = 'Données de la route (homeAirport - pairedAirport)',
    xaxis = dict(title='Direction'),
    yaxis = dict(title='Pax'),
    showlegend = False
)

# Création de la figure
fig = go.Figure(data=flight_trace, layout=layout)
fig.show()

(traffic_df
 .query('home_airport == "LIS" and paired_airport == "ORY"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
 .set_index('date')
 ['pax_total']
 .plot(figsize=(12, 6))
);

import plotly.graph_objects as go
import pandas as pd

# Obtention des données agrégées pour la route spécifiée
route_data = (traffic_df
              .query('home_airport == "LIS" and paired_airport == "ORY"')
              .groupby(['home_airport', 'paired_airport', 'date'])
              .agg(pax_total=('pax', 'sum'))
              .reset_index()
              .set_index('date'))

# Création de la trace de vol
flight_trace = go.Scatter(
    x = route_data.index,
    y = route_data['pax_total'],
    mode = 'lines+markers',
    line = dict(color='blue'),
    marker = dict(symbol='circle', size=6, color='blue'),
    hovertemplate = 'Date: %{x}<br>Pax Total: %{y}',
    name = 'Pax Total'
)

# Création de la mise en page du graphique
layout = go.Layout(
    title = 'Données de la route LIS - ORY',
    xaxis = dict(title='Date'),
    yaxis = dict(title='Pax Total'),
    showlegend = False
)

# Création de la figure
fig = go.Figure(data=flight_trace, layout=layout)
fig.show()

import datetime
import plotly

import plotly.offline as pyoff
import plotly.graph_objs as go

from plotly.subplots import make_subplots

def draw_ts_multiple(df, v1, v2=None, prediction=None, date='date',
                     secondary_y=True, covid_zone=False, display=True):
    if isinstance(v1, str):
        variables = [(v1, 'V1')]
    else:
        variables = [(v, 'V1.{}'.format(i)) for i, v in enumerate(v1)]
    title = '<br>'.join([n + ': ' + v for v, n in variables]) + ('<br>V2: ' + v2) if v2 else '<br>'.join(
        [v + ': ' + n for v, n in variables])
    layout = dict(
        title=title,
        xaxis=dict(
            rangeselector=dict(
                buttons=list([
                    dict(count=1,
                         label='1m',
                         step='month',
                         stepmode='backward'),
                    dict(count=6,
                         label='6m',
                         step='month',
                         stepmode='backward'),
                    dict(step='all')
                ])
            ),
            rangeslider=dict(
                visible=True
            ),
            type='date'
        )
    )
    fig = make_subplots(specs=[[{"secondary_y": True}]])
    fig.update_layout(layout)
    for v, name in variables:
        fig.add_trace(go.Scatter(x=df[date], y=df[v], name=name), secondary_y=False)
    if v2:
        fig.add_trace(go.Scatter(x=df[date], y=df[v2], name='V2'), secondary_y=secondary_y)
        fig['layout']['yaxis2']['showgrid'] = False
        fig.update_yaxes(rangemode='tozero')
        fig.update_layout(margin=dict(t=125 + 30 * (len(variables) - 1)))
    if prediction:
        fig.add_trace(go.Scatter(x=df[date], y=df[prediction], name='^V1', line={'dash': 'dot'}), secondary_y=False)

    if covid_zone:
        fig.add_vrect(
            x0=pd.Timestamp("2020-03-01"), x1=pd.Timestamp("2022-01-01"),
            fillcolor="Gray", opacity=0.5,
            layer="below", line_width=0,
        )
    if display:
        pyoff.iplot(fig)
    return fig

draw_ts_multiple(
    (traffic_df
     .query('home_airport == "LIS" and paired_airport == "ORY"')
     .groupby(['home_airport', 'paired_airport', 'date'])
     .agg(pax_total=('pax', 'sum'))
     .reset_index()
    ),
    'pax_total',
    covid_zone=True,
)

"""## 3.Afficher la série temporelle avec un graphique Plotly"""

# Filtrer les données pour le trajet spécifique LIS - ORY
filtered_data = traffic_df.query('home_airport == "LIS" and paired_airport == "ORY"')

# Regrouper les données par date et calculer le nombre total de passagers
grouped_data = filtered_data.groupby(['home_airport', 'paired_airport', 'date']).agg(
    pax_total=('pax', 'sum')
).reset_index()

# Créer le graphique Plotly
fig = go.Figure(data=go.Scatter(x=grouped_data['date'], y=grouped_data['pax_total'], mode='lines'))
fig.update_layout(title='Passenger Traffic on LIS-ORY Route', xaxis_title='Date', yaxis_title='Passenger Count')

# Afficher le graphique
fig.show()

"""## 2. Entrainement d’un modèle Prophet pour une route donnée avec une prévision de x
jours
"""

!pip install fbprophet

import pandas as pd
from fbprophet import Prophet

# Charger les données spécifiques de la route
data = traffic_df.query('home_airport == "LIS" and paired_airport == "ORY"') 

# Renommer les colonnes 'date' et 'pax' pour correspondre aux exigences de Prophet
data = data.rename(columns={'date': 'ds', 'pax': 'y'})

# Créer une instance du modèle Prophet
model = Prophet()

# Entraîner le modèle
model.fit(data)

# Prévoir pour les 7 prochains jours
future = model.make_future_dataframe(periods=7)

# Faire la prédiction
forecast = model.predict(future)

# Afficher la prédiction pour les 7 prochains jours
forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7)

"""## 4.Ecrire une fonction réalisant une prédiction du trafic"""

from fbprophet import Prophet

def forecast_traffic(data, date_col, target_col, forecast_period):
    """
    Réalise une prédiction du trafic pour la route sélectionnée en utilisant Prophet.

    Args:
    - data (pandas.DataFrame): DataFrame contenant les données de trafic
    - date_col (str): Nom de la colonne contenant les dates
    - target_col (str): Nom de la colonne contenant la variable cible à prédire (trafic)
    - forecast_period (int): Période de prévision en jours

    Returns:
    - forecast (pandas.DataFrame): DataFrame contenant les prédictions du trafic

    """

    # Filtrer les données pour la route sélectionnée
    route_data = data[['date', target_col]].copy()

    # Renommer les colonnes pour les besoins de Prophet
    route_data = route_data.rename(columns={date_col: 'ds', target_col: 'y'})

    # Instancier le modèle Prophet
    model = Prophet()

    # Entraîner le modèle sur les données
    model.fit(route_data)

    # Créer les dates de prévision pour la période spécifiée
    future_dates = model.make_future_dataframe(periods=forecast_period, include_history=False)

    # Effectuer la prédiction du trafic
    forecast = model.predict(future_dates)

    return forecast

"""## 5.Afficher le résultat de la prédiction dans le graphique"""

import pandas as pd
import plotly.graph_objects as go
from fbprophet import Prophet

# Charger les données spécifiques de la route
data = traffic_df.query('home_airport == "LIS" and paired_airport == "ORY"') 
# Filtrer les données pour la route spécifique
filtered_data = data.query('home_airport == "LIS" and paired_airport == "ORY"')

# Groupement des données par date et calcul du total des passagers
grouped_data = filtered_data.groupby('date').agg({'pax': 'sum'}).reset_index()

# Renommer les colonnes pour Prophet
grouped_data = grouped_data.rename(columns={'date': 'ds', 'pax': 'y'})

# Création d'une instance du modèle Prophet
model = Prophet()

# Entraînement du modèle
model.fit(grouped_data)

# Prévision pour 7 jours à partir de la dernière date disponible
future_dates = model.make_future_dataframe(periods=7)
forecast = model.predict(future_dates)

# Ajouter les prédictions au graphique existant
fig = go.Figure(data=go.Scatter(x=grouped_data['ds'], y=grouped_data['y'], mode='lines', name='Données historiques'))
fig.add_trace(go.Scatter(x=forecast['ds'], y=forecast['yhat'], mode='lines', name='Prédictions', line=dict(dash='dash')))

# Affichage du graphique
fig.show()

nte_fue_df = (traffic_df
 .query('home_airport == "LIS" and paired_airport == "ORY"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
)
nte_fue_df

lgw_ams_df = (traffic_df
 .query('home_airport == "LIS" and paired_airport == "ORY"')
 .groupby(['home_airport', 'paired_airport', 'date'])
 .agg(pax_total=('pax', 'sum'))
 .reset_index()
)
lgw_ams_df

from prophet import Prophet

baseline_model = Prophet()
baseline_model.fit(generate_route_df(traffic_df, "LIS", "ORY").rename(columns={'date': 'ds', 'pax_total': 'y'}))

future_df = baseline_model.make_future_dataframe(periods=7) # Prepare to predict 7 days
future_df

forecast_df = baseline_model.predict(future_df)

forecast_df

graph = baseline_model.plot(forecast_df)

baseline_model.plot_components(forecast_df);

from prophet.diagnostics import cross_validation

eval_df = cross_validation(baseline_model, initial='366 days', period='90 days', horizon='90 days')

eval_df

from prophet.diagnostics import performance_metrics

performance_metrics(eval_df)

from prophet.plot import plot_cross_validation_metric

plot_cross_validation_metric(eval_df, metric='rmse');

import lightgbm as lgb
import xgboost as xgb
from sklearn.ensemble import RandomForestRegressor

from mlforecast import MLForecast
from numba import njit
from window_ops.expanding import expanding_mean
from window_ops.rolling import rolling_mean

tested_models = [
    lgb.LGBMRegressor(),
    xgb.XGBRegressor(),
    RandomForestRegressor(random_state=0),
]

@njit
def rolling_mean_28(x):
    return rolling_mean(x, window_size=28)


fcst = MLForecast(
    models=tested_models,
    freq='D',
    lags=[7, 14, 21, 28],
    lag_transforms={
        1: [expanding_mean],
        7: [rolling_mean_28]
    },
    date_features=['dayofweek'],
    differences=[1],
)

nixtla_model = fcst.fit(generate_route_df(traffic_df, "LIS", "ORY").drop(columns=['paired_airport']),
                        id_col='home_airport', time_col='date', target_col='pax_total')

predict_df = nixtla_model.predict(7)
predict_df

(pd.concat([generate_route_df(traffic_df, 'LIS', 'ORY').drop(columns=['paired_airport']),
            nixtla_model.predict(7*10)])
.set_index('date')
).plot(figsize=(15, 7));

draw_ts_multiple((pd.concat([generate_route_df(traffic_df, 'LIS', 'ORY').drop(columns=['paired_airport']),
                             nixtla_model.predict(7*10)])),
                 v1='pax_total', v2='LGBMRegressor');

"""Streamlit

"""

!pip install streamlit

import streamlit as st

# Streamlit app code
def main():
    # Set Streamlit app title
    st.title("My Streamlit App")
    
    # Add your content and functionality here
    st.write("Hello, Streamlit!")

if __name__ == '__main__':
    main()